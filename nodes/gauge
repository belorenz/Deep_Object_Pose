#!/usr/bin/env python

"""
This file starts a ROS node to run DOPE Performance Gauge,
publishing to an image topic and subscribing resulting poses.
"""

from __future__ import print_function

import glob
import json
import math
import os

import cv2
import rospy
from camera_info_manager import CameraInfoManager
from cv_bridge import CvBridge, CvBridgeError
from sensor_msgs.msg import Image, CameraInfo
from vision_msgs.msg import Detection3DArray

from geometry_msgs.msg import Point
from dope.msg import ProjectedCuboidArray
from dope.msg import ProjectedCuboid

try:
    import queue
except ImportError:
    import Queue as queue

class Result:

    def __init__(self, id, image=None, cuboids=None, detections=None):
        self.id = id
        self.image = image
        self.cuboids = cuboids
        self.detections = detections

    def is_complete(self):
        return self.image and self.cuboids and self.detections

class DopePerformanceGauge:

    def __init__(self):
        self.image_dir = rospy.get_param('~image_dir',
                                         '/media/benjamin/Liesbeth/MultiCarPose_v0.9/eval')
        self.image_output_dir = rospy.get_param('~image_output_dir', '')
        self.topic_camera_info = rospy.get_param('~topic_camera_info',
                                                 '/dope/gauge/camera_info')
        self.topic_image = rospy.get_param('~topic_image',
                                           '/dope/gauge/image_raw')
        self.topic_incoming_image = '/dope/rgb_points'
        self.image_pub = rospy.Publisher(self.topic_image, Image, queue_size=10)
        self.info_pub = rospy.Publisher(self.topic_camera_info, CameraInfo,
                                        queue_size=10)

        rospy.loginfo('Publishing images to {}.'.format(self.topic_image))
        rospy.loginfo('Subscribing to incoming images from {}.'.format(
            self.topic_incoming_image))
        rospy.loginfo('Publishing camera_infos to {}.'.format(self.topic_camera_info))
        rospy.loginfo('Saving Images to{}.'.format(self.image_output_dir))

        self.camera_info = None
        self.test_data = {} # {image_filename : annotation_filename}

        self.bridge = CvBridge()

        self.cuboid_que = queue.Queue()
        self.image_que = queue.Queue()
        self.detections_que = queue.Queue()

        self.sub_rgb = rospy.Subscriber(self.topic_incoming_image, Image,
                                     self._image_callback)
        self.sub_cuboids = rospy.Subscriber( '/dope/cuboid_array',
                                     ProjectedCuboidArray, self._cuboid_callback)
        self.sub_objects = rospy.Subscriber('/dope/detected_objects',
                                    Detection3DArray, self._detection_callback)

        self.publish_counter = 0
        self.subscribe_counter = 0
        self.results = {}

    def run(self):
        self._read_cam_info()
        self._fetch_test_data()

        self.rate = rospy.Rate(30)


        for image_filename in self.test_data:
            while (self.publish_counter - self.subscribe_counter) > 10:
                rospy.logdebug('Delay publishing until new data arrives.')
                self.rate.sleep()

            image = cv2.imread(image_filename)
            image_message = self.bridge.cv2_to_imgmsg(image, "bgr8")
            assert len(image_filename) > 10
            image_id = image_filename[-10:-4]

            image_message.header.frame_id = image_id
            image_message.header.stamp = rospy.Time.now()

            self.image_pub.publish(image_message)
            self.camera_info.header = image_message.header
            self.info_pub.publish(self.camera_info)
            rospy.logdebug('Published image {} and camera_info!'.format(
                image_message.header.frame_id))
            self.publish_counter += 1
            self.rate.sleep()
            self._evaluate()


    def _fetch_test_data(self):
        rospy.loginfo('Fetching test_data..')
        all_images = glob.glob(self.image_dir + "/*.png")
        assert len(all_images) > 0
        for image_filename in all_images:
            annotation_filename = image_filename[:-3] + "json"
            if os.path.exists(annotation_filename):
                self.test_data.update({image_filename : annotation_filename})
        rospy.loginfo('Fetched {} images.'.format(len(all_images)))


    def _read_cam_info(self):
        rospy.loginfo('Read Camera_info..')
        camera_namespace = rospy.get_param('camera', 'dope/webcam')
        camera_info_url = rospy.get_param('~camera_info_url',
                                          'file:///home/benjamin/catkin_ws/src/dope/config/camera_info_gauge.yaml')
        self.info_manager = CameraInfoManager(cname='dope_webcam_{}'.format(0),
                                         namespace=camera_namespace)
        try:
            if not self.info_manager.setURL(camera_info_url):
                raise RuntimeError('Camera info URL invalid: %s', camera_info_url)
        except KeyError:
            # we don't have a camera_info_url, so we'll keep the
            # default ('file://${ROS_HOME}/camera_info/${NAME}.yaml')
            pass

        self.info_manager.loadCameraInfo()
        if not self.info_manager.isCalibrated():
            raise RuntimeError('Camera is not calibrated, please supply a valid camera_info_url parameter!')
        self.camera_info = self.info_manager.getCameraInfo()

    def _evaluate(self):
        #todo queues entleeren, fertige results auswerten und zur
        # gesamtwertung hinzuf√ºgen
        image_id = detection_msg.header.frame_id
        with open('data.txt') as json_file:
            gt_annotation = json.load(self.image_dir + "/" + str(
                image_id)+".json")

        for gt_object in gt_annotation['objects']:
            gt_centroid = gt_object['projected_cuboid_centroid']
            for detection in detection_msg:
                distance = math.sqrt(detection)

        id = msg.header.frame_id
        result = self.results.get(id, Result(id))
        result.detections = msg.detections
        rospy.logdebug("Received detections for frame: {}".format(str(id)))
        if result.is_complete():
            self.evaluate(result)


    def _image_callback(self, msg):
        self.image_que.put(msg)

    def _cuboid_callback(self,msg):
        self.cuboid_que.put(msg)

    def _detection_callback(self, msg):
        self.detections_que.put(msg)

    def _caluclate_ADDS(self, ground_truth, inference):
        pass

    def draw_line(self, point1, point2, line_color, line_width=5):
        """Draws line on image"""
        if point1 is not None and point2 is not None:
            self.draw.line([point1, point2], fill=line_color, width=line_width)

    def draw_cube(self, points, color=(0, 255, 0)):
        """
        Draws cube with a thick solid line across
        the front top edge and an X on the top face.
        """

        # draw front
        self.draw_line(points[0], points[1], color)
        self.draw_line(points[1], points[2], color)
        self.draw_line(points[3], points[2], color)
        self.draw_line(points[3], points[0], color)

        # draw back
        self.draw_line(points[4], points[5], color)
        self.draw_line(points[6], points[5], color)
        self.draw_line(points[6], points[7], color)
        self.draw_line(points[4], points[7], color)

        # draw sides
        self.draw_line(points[0], points[4], color)
        self.draw_line(points[7], points[3], color)
        self.draw_line(points[5], points[1], color)
        self.draw_line(points[2], points[6], color)

        # draw dots
        self.draw_dot(points[0], point_color=color, point_radius=4)
        self.draw_dot(points[1], point_color=color, point_radius=4)

        # draw x on the top
        self.draw_line(points[0], points[5], color)
        self.draw_line(points[1], points[4], color)



if __name__ == "__main__":
    # Initialize ROS node
    rospy.loginfo('Init Gauge..')


    try:
        rospy.init_node('dope_performance_gauge', anonymous=True,
                        log_level=rospy.DEBUG)
        DopePerformanceGauge().run()
        rospy.spin()

    except rospy.ROSInterruptException:
        pass
    else:
        rospy.loginfo('\nFinished Dataset.\n')

