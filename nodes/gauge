#!/usr/bin/env python

"""
This file starts a ROS node to run DOPE Performance Gauge,
publishing to an image topic and subscribing resulting poses.
"""

from __future__ import print_function

import time
import cv2
import rospy
import glob
import os

from camera_info_manager import CameraInfoManager
from sensor_msgs.msg import Image, CameraInfo
from geometry_msgs.msg import PoseStamped
from cv_bridge import CvBridge, CvBridgeError
from std_msgs.msg import String
from vision_msgs.msg import Detection3DArray
from collections import defaultdict


try:
    import queue
except ImportError:
    import Queue as queue


class DopePerformanceGauge:

    def __init__(self):
        self.image_dir = rospy.get_param('~image_dir',
                                         '/media/benjamin/Liesbeth/MultiCarPose_v0.9/eval')
        self.image_output_dir = rospy.get_param('~image_output_dir', '')
        self.topic_camera_info = rospy.get_param('~topic_camera_info',
                                                 '/dope/gauge/camera_info')
        self.topic_image = rospy.get_param('~topic_image',
                                           '/dope/gauge/image_raw')
        self.image_pub = rospy.Publisher(self.topic_image, Image, queue_size=10)
        self.info_pub = rospy.Publisher(self.topic_camera_info, CameraInfo,
                                        queue_size=10)

        print('Publishing images to {}.'.format(self.topic_image))
        print('Publishing camera_infos to {}.'.format(self.topic_camera_info))

        self.camera_info = None
        self.test_data = {} # {image_filename : annotation_filename}

        self.bridge = CvBridge()

        self.dimensions_que = queue.Queue()
        self.pose_car_que = queue.Queue()
        self.rgb_que = queue.Queue()
        self.objects_que = queue.Queue()

        #self.sub_dimensions= rospy.Subscriber('/dope/dimensions_car', String,
        #                                     self._image_callback)
        #self.sub_pose = rospy.Subscriber('/dope/pose_car', PoseStamped,
        #                                     self._image_callback)
        self.sub_rgb = rospy.Subscriber('/dope/rgb_points', Image,
                                             self._image_callback)
        #self.sub_objects = rospy.Subscriber('/dope/detected_objects',
        # Detection3DArray,
        #                                     self._image_callback)

        #self.received_messages = defaultdict(lambda : {'rgb' : None,
        #                                                 'objects': None,
        #                                                 'poses': [],
        #                                                 'dimensions': []} )

    def run(self):
        self._read_cam_info()
        self._fetch_test_data()

        rate = rospy.Rate(15)


        print('Waiting 15s for DOPE to start..')
        time.sleep(15)
        for image_filename in self.test_data:
            while self.rgb_que.qsize() >= 5:
                print('Incoming image que too long, waiting until it is '
                      'processed.')
                rate.sleep()


            image = cv2.imread(image_filename)
            image_message = self.bridge.cv2_to_imgmsg(image, "bgr8")
            assert len(image_filename) > 10
            image_id = image_filename[-10:-4]

            image_message.header.frame_id = image_id
            image_message.header.stamp = rospy.Time.now()

            self.image_pub.publish(image_message)
            self.camera_info.header = image_message.header
            self.info_pub.publish(self.camera_info)
            print('Published image {} and camera_info!'.format(
                image_message.header.frame_id))

            # todo evaluate messages in queues

            rate.sleep()

    def _assemble_output(self):
        for image in list(self.rgb_que):
            pass

    def calculate_ground_truth(self):
        pass

    def _fetch_test_data(self):
        print('Fetching test_data..')
        all_images = glob.glob(self.image_dir + "/*.png")
        assert len(all_images) > 0
        for image_filename in all_images:
            annotation_filename = image_filename[:-3] + "json"
            if os.path.exists(annotation_filename):
                self.test_data.update({image_filename : annotation_filename})
        print('Fetched {} images.'.format(len(all_images)))


    def _read_cam_info(self):
        print('Read Camera_info..')
        camera_namespace = rospy.get_param('camera', 'dope/webcam')
        camera_info_url = rospy.get_param('~camera_info_url',
                                          'file:///home/benjamin/catkin_ws/src/dope/config/camera_info_gauge.yaml')
        self.info_manager = CameraInfoManager(cname='dope_webcam_{}'.format(0),
                                         namespace=camera_namespace)
        try:
            if not self.info_manager.setURL(camera_info_url):
                raise RuntimeError('Camera info URL invalid: %s', camera_info_url)
        except KeyError:
            # we don't have a camera_info_url, so we'll keep the
            # default ('file://${ROS_HOME}/camera_info/${NAME}.yaml')
            pass

        self.info_manager.loadCameraInfo()
        if not self.info_manager.isCalibrated():
            raise RuntimeError('Camera is not calibrated, please supply a valid camera_info_url parameter!')
        self.camera_info = self.info_manager.getCameraInfo()

    def _image_callback(self, msg):
        try:
            image_id = msg.header.frame_id
            print("Received image: {}".format(str(msg.header)))
            # Convert your ROS Image message to OpenCV2
            cv2_img = self.bridge.imgmsg_to_cv2(msg, "bgr8")
        except CvBridgeError, e:
            print(e)
        else:
            # Save your OpenCV2 image as a png
            image_id = msg.header.frame_id
            cv2.imwrite(self.image_output_dir + '/' + str(image_id)+'.png',
                        cv2_img)
            rospy.sleep(1)

        #elif type(msg) is String:
        #    self.dimensions_que.put(msg)
        #elif type(msg) is PoseStamped:
        #    self.pose_car_que.put(msg)
        #elif type(msg) is Detection3DArray:
        #    self.objects_que.put(msg)
        #else:
        #    raise RuntimeError('Message of unknown type received.')


def _callback(self):
        pass


if __name__ == "__main__":
    # Initialize ROS node
    print('Init Gauge..')
    rospy.init_node('dope_performance_gauge', anonymous=True)
    DopePerformanceGauge().run()
    print('\nFinished Dataset.\n')

    #try:
    #    rospy.spin()
    #except rospy.ROSInterruptException:
    #    pass
